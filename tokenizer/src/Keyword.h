
#ifndef KEYWORD_H
#define KEYWORD_H

#include <map>
#include <string>

#include "TokenId.h"

/** Classify identifiers into keywords */
class Keyword {
public:
	enum IdentifierType {
		FIRST = TokenId::KEYWORD,
		IDENTIFIER,	// Plain identifier (not a keyword)
		K_False,
		K_None,
		K_True,
		K_abstract,
		K_alignas,
		K_alignof,
		K_and,
		K_and_eq,
		K_array,
		K_as,
		K_asm,
		K_assert,
		K_async,
		K_atomic_cancel,
		K_atomic_commit,
		K_atomic_noexcept,
		K_auto,
		K_await,
		K_base,
		K_bitand,
		K_bitor,
		K_bool,
		K_boolean,
		K_break,
		K_byte,
		K_callable,
		K_case,
		K_catch,
		K_char,
		K_char16_t,
		K_char32_t,
		K_checked,
		K_class,
		K_clone,
		K_co_await,
		K_co_return,
		K_co_yield,
		K_compl,
		K_concept,
		K_const,
		K_const_cast,
		K_constexpr,
		K_continue,
		K_decimal,
		K_declare,
		K_decltype,
		K_def,
		K_default,
		K_define,
		K_del,
		K_delegate,
		K_delete,
		K_die,
		K_do,
		K_double,
		K_dynamic_cast,
		K_echo,
		K_elif,
		K_else,
		K_elseif,
		K_empty,
		K_enddeclare,
		K_endfor,
		K_endforeach,
		K_endif,
		K_endregion,
		K_endswitch,
		K_endwhile,
		K_enum,
		K_error,
		K_eval,
		K_event,
		K_except,
		K_exit,
		K_explicit,
		K_export,
		K_extends,
		K_extern,
		K_false,
		K_final,
		K_finally,
		K_fixed,
		K_float,
		K_for,
		K_foreach,
		K_friend,
		K_from,
		K_function,
		K_global,
		K_goto,
		K_if,
		K_ifdef,
		K_ifndef,
		K_implements,
		K_implicit,
		K_import,
		K_in,
		K_include,
		K_include_once,
		K_inline,
		K_instanceof,
		K_insteadof,
		K_int,
		K_interface,
		K_internal,
		K_is,
		K_isset,
		K_lambda,
		K_line,
		K_list,
		K_lock,
		K_long,
		K_module,
		K_mutable,
		K_namespace,
		K_native,
		K_new,
		K_noalias,
		K_noexcept,
		K_nonlocal,
		K_not,
		K_not_eq,
		K_null,
		K_nullptr,
		K_object,
		K_operator,
		K_or,
		K_or_eq,
		K_out,
		K_override,
		K_package,
		K_params,
		K_pass,
		K_pragma,
		K_print,
		K_private,
		K_protected,
		K_public,
		K_raise,
		K_readonly,
		K_ref,
		K_region,
		K_register,
		K_reinterpret_cast,
		K_require,
		K_require_once,
		K_requires,
		K_restrict,
		K_return,
		K_sbyte,
		K_sealed,
		K_short,
		K_signed,
		K_sizeof,
		K_stackalloc,
		K_static,
		K_static_assert,
		K_static_cast,
		K_strictfp,
		K_string,
		K_struct,
		K_super,
		K_switch,
		K_synchronized,
		K_template,
		K_this,
		K_thread_local,
		K_throw,
		K_throws,
		K_trait,
		K_transient,
		K_true,
		K_try,
		K_typedef,
		K_typeid,
		K_typename,
		K_typeof,
		K_uint,
		K_ulong,
		K_unchecked,
		K_undef,
		K_union,
		K_unsafe,
		K_unset,
		K_unsigned,
		K_use,
		K_ushort,
		K_using,
		K_var,
		K_virtual,
		K_void,
		K_volatile,
		K_warning,
		K_wchar_t,
		K_while,
		K_with,
		K_xor,
		K_xor_eq,
		K_yield,

		LAST,		// Last value (295)
	};
private:
	// Keyword map
	typedef std::map <std::string, enum IdentifierType> KeywordMap;
	typedef std::map <int, std::string> TokenMap;
	KeywordMap km;
	TokenMap tm;
public:
	Keyword() {
		km = {
			{"decltype", K_decltype },
			{"ifndef", K_ifndef },
			{"const", K_const },
			{"dynamic_cast", K_dynamic_cast },
			{"define", K_define },
			{"co_yield", K_co_yield },
			{"bool", K_bool },
			{"enum", K_enum },
			{"instanceof", K_instanceof },
			{"boolean", K_boolean },
			{"signed", K_signed },
			{"operator", K_operator },
			{"int", K_int },
			{"typedef", K_typedef },
			{"implements", K_implements },
			{"throw", K_throw },
			{"async", K_async },
			{"nullptr", K_nullptr },
			{"new", K_new },
			{"params", K_params },
			{"noexcept", K_noexcept },
			{"true", K_true },
			{"die", K_die },
			{"module", K_module },
			{"requires", K_requires },
			{"global", K_global },
			{"extern", K_extern },
			{"asm", K_asm },
			{"default", K_default },
			{"bitand", K_bitand },
			{"or_eq", K_or_eq },
			{"enddeclare", K_enddeclare },
			{"this", K_this },
			{"transient", K_transient },
			{"typename", K_typename },
			{"raise", K_raise },
			{"with", K_with },
			{"stackalloc", K_stackalloc },
			{"use", K_use },
			{"print", K_print },
			{"isset", K_isset },
			{"switch", K_switch },
			{"empty", K_empty },
			{"region", K_region },
			{"case", K_case },
			{"catch", K_catch },
			{"include", K_include },
			{"const_cast", K_const_cast },
			{"package", K_package },
			{"unchecked", K_unchecked },
			{"declare", K_declare },
			{"from", K_from },
			{"atomic_cancel", K_atomic_cancel },
			{"static_cast", K_static_cast },
			{"not_eq", K_not_eq },
			{"include_once", K_include_once },
			{"short", K_short },
			{"reinterpret_cast", K_reinterpret_cast },
			{"abstract", K_abstract },
			{"break", K_break },
			{"else", K_else },
			{"not", K_not },
			{"endregion", K_endregion },
			{"virtual", K_virtual },
			{"extends", K_extends },
			{"bitor", K_bitor },
			{"sealed", K_sealed },
			{"endforeach", K_endforeach },
			{"endswitch", K_endswitch },
			{"try", K_try },
			{"pragma", K_pragma },
			{"unset", K_unset },
			{"wchar_t", K_wchar_t },
			{"for", K_for },
			{"float", K_float },
			{"super", K_super },
			{"event", K_event },
			{"import", K_import },
			{"ifdef", K_ifdef },
			{"True", K_True },
			{"null", K_null },
			{"lambda", K_lambda },
			{"final", K_final },
			{"char32_t", K_char32_t },
			{"clone", K_clone },
			{"strictfp", K_strictfp },
			{"using", K_using },
			{"implicit", K_implicit },
			{"decimal", K_decimal },
			{"do", K_do },
			{"alignas", K_alignas },
			{"sizeof", K_sizeof },
			{"callable", K_callable },
			{"constexpr", K_constexpr },
			{"endfor", K_endfor },
			{"echo", K_echo },
			{"goto", K_goto },
			{"while", K_while },
			{"assert", K_assert },
			{"endif", K_endif },
			{"False", K_False },
			{"if", K_if },
			{"char", K_char },
			{"thread_local", K_thread_local },
			{"pass", K_pass },
			{"await", K_await },
			{"co_return", K_co_return },
			{"typeid", K_typeid },
			{"is", K_is },
			{"unsafe", K_unsafe },
			{"and_eq", K_and_eq },
			{"double", K_double },
			{"line", K_line },
			{"elif", K_elif },
			{"sbyte", K_sbyte },
			{"throws", K_throws },
			{"xor_eq", K_xor_eq },
			{"lock", K_lock },
			{"char16_t", K_char16_t },
			{"def", K_def },
			{"unsigned", K_unsigned },
			{"volatile", K_volatile },
			{"private", K_private },
			{"string", K_string },
			{"atomic_noexcept", K_atomic_noexcept },
			{"override", K_override },
			{"finally", K_finally },
			{"endwhile", K_endwhile },
			{"restrict", K_restrict },
			{"namespace", K_namespace },
			{"checked", K_checked },
			{"inline", K_inline },
			{"error", K_error },
			{"trait", K_trait },
			{"object", K_object },
			{"del", K_del },
			{"warning", K_warning },
			{"static", K_static },
			{"fixed", K_fixed },
			{"list", K_list },
			{"atomic_commit", K_atomic_commit },
			{"eval", K_eval },
			{"concept", K_concept },
			{"long", K_long },
			{"or", K_or },
			{"template", K_template },
			{"require_once", K_require_once },
			{"except", K_except },
			{"array", K_array },
			{"yield", K_yield },
			{"compl", K_compl },
			{"explicit", K_explicit },
			{"return", K_return },
			{"base", K_base },
			{"protected", K_protected },
			{"alignof", K_alignof },
			{"public", K_public },
			{"foreach", K_foreach },
			{"delete", K_delete },
			{"delegate", K_delegate },
			{"export", K_export },
			{"undef", K_undef },
			{"uint", K_uint },
			{"xor", K_xor },
			{"readonly", K_readonly },
			{"byte", K_byte },
			{"and", K_and },
			{"class", K_class },
			{"exit", K_exit },
			{"out", K_out },
			{"static_assert", K_static_assert },
			{"None", K_None },
			{"var", K_var },
			{"elseif", K_elseif },
			{"in", K_in },
			{"auto", K_auto },
			{"interface", K_interface },
			{"co_await", K_co_await },
			{"register", K_register },
			{"insteadof", K_insteadof },
			{"native", K_native },
			{"nonlocal", K_nonlocal },
			{"continue", K_continue },
			{"synchronized", K_synchronized },
			{"void", K_void },
			{"as", K_as },
			{"union", K_union },
			{"struct", K_struct },
			{"ref", K_ref },
			{"typeof", K_typeof },
			{"friend", K_friend },
			{"internal", K_internal },
			{"ushort", K_ushort },
			{"mutable", K_mutable },
			{"function", K_function },
			{"false", K_false },
			{"noalias", K_noalias },
			{"require", K_require },
			{"ulong", K_ulong },

		};
		tm = {
			{K_print, "print" },
			{K_double, "double" },
			{K_default, "default" },
			{K_die, "die" },
			{K_wchar_t, "wchar_t" },
			{K_bitor, "bitor" },
			{K_with, "with" },
			{K_unsigned, "unsigned" },
			{K_class, "class" },
			{K_ulong, "ulong" },
			{K_finally, "finally" },
			{K_eval, "eval" },
			{K_pragma, "pragma" },
			{K_False, "False" },
			{K_friend, "friend" },
			{K_use, "use" },
			{K_sealed, "sealed" },
			{K_ifdef, "ifdef" },
			{K_long, "long" },
			{K_decimal, "decimal" },
			{K_catch, "catch" },
			{K_internal, "internal" },
			{K_goto, "goto" },
			{K_noexcept, "noexcept" },
			{K_as, "as" },
			{K_super, "super" },
			{K_implements, "implements" },
			{K_array, "array" },
			{K_int, "int" },
			{K_nonlocal, "nonlocal" },
			{K_event, "event" },
			{K_foreach, "foreach" },
			{K_isset, "isset" },
			{K_restrict, "restrict" },
			{K_interface, "interface" },
			{K_elif, "elif" },
			{K_while, "while" },
			{K_readonly, "readonly" },
			{K_global, "global" },
			{K_virtual, "virtual" },
			{K_sbyte, "sbyte" },
			{K_require, "require" },
			{K_list, "list" },
			{K_fixed, "fixed" },
			{K_co_await, "co_await" },
			{K_continue, "continue" },
			{K_stackalloc, "stackalloc" },
			{K_co_yield, "co_yield" },
			{K_del, "del" },
			{K_object, "object" },
			{K_endregion, "endregion" },
			{K_def, "def" },
			{K_typedef, "typedef" },
			{K_export, "export" },
			{K_exit, "exit" },
			{K_from, "from" },
			{K_break, "break" },
			{K_unset, "unset" },
			{K_switch, "switch" },
			{K_throws, "throws" },
			{K_endswitch, "endswitch" },
			{K_xor, "xor" },
			{K_not_eq, "not_eq" },
			{K_static_cast, "static_cast" },
			{K_boolean, "boolean" },
			{K_char16_t, "char16_t" },
			{K_string, "string" },
			{K_uint, "uint" },
			{K_using, "using" },
			{K_endwhile, "endwhile" },
			{K_this, "this" },
			{K_explicit, "explicit" },
			{K_async, "async" },
			{K_unsafe, "unsafe" },
			{K_new, "new" },
			{K_package, "package" },
			{K_True, "True" },
			{K_abstract, "abstract" },
			{K_is, "is" },
			{K_unchecked, "unchecked" },
			{K_insteadof, "insteadof" },
			{K_if, "if" },
			{K_char32_t, "char32_t" },
			{K_register, "register" },
			{K_var, "var" },
			{K_compl, "compl" },
			{K_ifndef, "ifndef" },
			{K_None, "None" },
			{K_instanceof, "instanceof" },
			{K_synchronized, "synchronized" },
			{K_assert, "assert" },
			{K_base, "base" },
			{K_alignas, "alignas" },
			{K_callable, "callable" },
			{K_echo, "echo" },
			{K_except, "except" },
			{K_union, "union" },
			{K_typeid, "typeid" },
			{K_elseif, "elseif" },
			{K_typename, "typename" },
			{K_decltype, "decltype" },
			{K_nullptr, "nullptr" },
			{K_case, "case" },
			{K_final, "final" },
			{K_ushort, "ushort" },
			{K_mutable, "mutable" },
			{K_out, "out" },
			{K_bitand, "bitand" },
			{K_warning, "warning" },
			{K_null, "null" },
			{K_not, "not" },
			{K_endforeach, "endforeach" },
			{K_false, "false" },
			{K_enum, "enum" },
			{K_struct, "struct" },
			{K_delegate, "delegate" },
			{K_lock, "lock" },
			{K_for, "for" },
			{K_include_once, "include_once" },
			{K_require_once, "require_once" },
			{K_static_assert, "static_assert" },
			{K_inline, "inline" },
			{K_pass, "pass" },
			{K_implicit, "implicit" },
			{K_native, "native" },
			{K_bool, "bool" },
			{K_strictfp, "strictfp" },
			{K_short, "short" },
			{K_requires, "requires" },
			{K_auto, "auto" },
			{K_define, "define" },
			{K_private, "private" },
			{K_operator, "operator" },
			{K_throw, "throw" },
			{K_region, "region" },
			{K_alignof, "alignof" },
			{K_co_return, "co_return" },
			{K_include, "include" },
			{K_trait, "trait" },
			{K_lambda, "lambda" },
			{K_error, "error" },
			{K_declare, "declare" },
			{K_asm, "asm" },
			{K_public, "public" },
			{K_empty, "empty" },
			{K_dynamic_cast, "dynamic_cast" },
			{K_noalias, "noalias" },
			{K_thread_local, "thread_local" },
			{K_try, "try" },
			{K_or_eq, "or_eq" },
			{K_yield, "yield" },
			{K_void, "void" },
			{K_and, "and" },
			{K_or, "or" },
			{K_true, "true" },
			{K_extern, "extern" },
			{K_concept, "concept" },
			{K_static, "static" },
			{K_reinterpret_cast, "reinterpret_cast" },
			{K_extends, "extends" },
			{K_byte, "byte" },
			{K_undef, "undef" },
			{K_delete, "delete" },
			{K_import, "import" },
			{K_endfor, "endfor" },
			{K_signed, "signed" },
			{K_constexpr, "constexpr" },
			{K_params, "params" },
			{K_atomic_commit, "atomic_commit" },
			{K_const_cast, "const_cast" },
			{K_override, "override" },
			{K_endif, "endif" },
			{K_transient, "transient" },
			{K_module, "module" },
			{K_enddeclare, "enddeclare" },
			{K_raise, "raise" },
			{K_const, "const" },
			{K_atomic_noexcept, "atomic_noexcept" },
			{K_clone, "clone" },
			{K_namespace, "namespace" },
			{K_volatile, "volatile" },
			{K_atomic_cancel, "atomic_cancel" },
			{K_return, "return" },
			{K_char, "char" },
			{K_checked, "checked" },
			{K_else, "else" },
			{K_float, "float" },
			{K_in, "in" },
			{K_function, "function" },
			{K_and_eq, "and_eq" },
			{K_template, "template" },
			{K_await, "await" },
			{K_sizeof, "sizeof" },
			{K_protected, "protected" },
			{K_xor_eq, "xor_eq" },
			{K_ref, "ref" },
			{K_line, "line" },
			{K_typeof, "typeof" },
			{K_do, "do" },

		};
	}

	enum IdentifierType identifier_type(const std::string &s) {
		auto f = km.find(s);
		if (f == km.end())
			return IDENTIFIER;
		else
			return f->second;
	}

	const std::string & to_string(int k) const {
		static const std::string UNKNOWN("???");

		auto t = tm.find(k);
		return t == tm.end() ? UNKNOWN : t->second;
	}
};
#endif /* KEYWORD_H */
